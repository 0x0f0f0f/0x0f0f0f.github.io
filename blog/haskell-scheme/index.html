<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/style.css"> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous  /> <link rel=stylesheet  href="/css/franklin.css"> <link rel=icon  href="/assets/favicon.ico"> <title>Learn Functional Programming by writing a Scheme in Haskell</title> <header> <a class=title  href="/"><h2>0x0f0f0f - Alessandro Cheli</h2></a> <nav> <a href="/">Home</a> / <a href="/blog">Blog</a> / <a href="/tag/">Tags</a> <div class=social-media > <a style="color: #000000;" href="https://github.com/0x0f0f0f"><i class="fab fa-github"></i></a> <a style="color: #000000;" href="https://twitter.com/0x0f0f0f1"><i class="fab fa-twitter"></i></a> </div> </nav> </header> <main> <div class=container ><h1>Learn Functional Programming by writing a Scheme in Haskell</h1> <p>Published 28 September 2019</p> <p><b>Tags: </b><a href="/tag/functional-programming">#functional-programming</a>, <a href="/tag/haskell">#haskell</a>, <a href="/tag/lisp">#lisp</a>, <a href="/tag/yasih">#yasih</a></p><hr/> <h2 id=how_to_make_your_first_functional_programming_language_a_book_review ><a href="#how_to_make_your_first_functional_programming_language_a_book_review" class=header-anchor >How to make your first functional programming language. A book review.</a></h2> <p>After taking an introductory functional programming course last year I have decided to dive into Functional Programming in a challenging way.</p> <p>At the beginning of the summer I&#39;ve asked an experienced friend some ideas for a summer project. He suggested me to implement <strong>R5RS Scheme</strong> &#40;Revised&#40;5&#41; Report on the Algorithmic Language Scheme&#41; in Haskell. Scheme is called a dialect of LISP &#40;<strong>LI</strong>st <strong>PR</strong>ocessor&#41;, a family of programming languages with a long history, famous for its fully parenthesized <a href="https://en.wikipedia.org/wiki/Polish_notation">prefix notation</a>. LISP showed computer scientists in the 60s the importance of <a href="https://en.wikipedia.org/wiki/Lambda_calculus">λ &#40;lambda&#41; calculus</a> and was originally specified in 1958 by John McCarthy, one of the founders of the Stanford AI Laboratory.</p> <p>I&#39;ve decided to call my Scheme implementation <strong>yasih</strong>, or <strong>Y</strong>et <strong>A</strong>nother <strong>S</strong>cheme <strong>I</strong>n <strong>H</strong>askell, since implementing a Scheme in Haskell is a popular exercise alongwise Computer Scientists. You can find the code in the <a href="https://github.com/0x0f0f0f/yasih">yasih repository</a> on my GitHub profile.</p> <p>At the time I only knew a little bit of OCaML and had some basic knowledge about λ-calculus and LISP, but I was itching for more knowledge about the internals and the history of functional programming. After a bit of googling I&#39;ve stumbled into the excellent book <a href="https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/">Write Yourself a Scheme in 48 Hours</a> and started diving into it.</p> <p>The book is raw, it was refined by the WikiBooks community after the original version was open sourced, hence it is still incomplete. Each chapter explains the interpreter code step by step and also presents you with some exercises. At the beginning, it goes straight to parsing and assumes that you have some &#40;basic&#41; functional programming background.</p> <p>Some Haskell concepts aren&#39;t explained clearly, while Scheme concepts are explained in much more detail. I had to do a lot of googling while reading each chapter. I also followed the <a href="https://groups.csail.mit.edu/mac/ftpdir/scheme-reports/r5rs-html/r5rs_toc.html">MIT R5RS spec</a> and the <a href="https://www.gnu.org/software/guile/docs/docs-1.6/guile-ref/R5RS-Index.html">Guile Scheme reference manual</a>. <a href="https://www.gnu.org/software/guile/">Guile</a> is the official scripting language of the GNU project and is a really great and fast implementation of the Scheme language. I&#39;ve used it in parallel to my Scheme to test the correctness of the primitives I&#39;ve implemented in my Scheme.</p> <p>A simple LISP interpreter is composed by 3 components:</p> <p>The first one, the <strong>parser</strong> is the section of interpreter that is responsible of reading each character, line-by-line, of a text file received in input &#40;the program&#41; and transform it into an <strong>AST</strong> &#40;Abstract Syntax Tree&#41;. The parser also performs some syntactical correctness checks. Here&#39;s an example of parsing a typical LISP parenthesized expression using the Parsec parser combinator library in Haskell:</p> <pre><code class="haskell hljs"><span class=hljs-title >parseExpr</span> :: <span class=hljs-type >Parser</span> <span class=hljs-type >LispVal</span>
<span class=hljs-title >parseExpr</span> = <span class=hljs-keyword >do</span>
    expr &lt;- try parseComplex
        &lt;|&gt; try parseRatio
        &lt;|&gt; try parseFloat
        &lt;|&gt; try parseNumber
        &lt;|&gt; try parseAtom
        &lt;|&gt; parseString
        &lt;|&gt; try parseBool
        &lt;|&gt; try parseCharacter
        &lt;|&gt; try parseQuoted
        &lt;|&gt; try parseQuasiQuoted
        &lt;|&gt; try parseUnQuote
        &lt;|&gt; try parseVector
        &lt;|&gt; try parseParens
    skipMany parseComment
    return expr</code></pre> <p>The <strong>AST</strong> then gets evalauted by the <strong>Evaluator</strong>. The <strong>Evaluator</strong> receives in input an <strong>AST</strong> from the parser, executes semantical correctness checks &#40;malformed forms, wrong argument numbers, unbound variables&#41; and then recursively applies form evaluation and function calls, &quot;executing&quot; the AST expression and returning a value. Evaluation steps in λ-calculus are called β-reduction &#40;applying functions to their arguments&#41; and η-conversion &#40;two functions are the same if and only if they give the same result for all arguments&#41;.</p> <p>&#40;The <a href="https://www.flickr.com/photos/71827087@N00/124183635/">April 1985 issue</a> of &quot;bit&quot;, a Japanese computer science magazine, which an introduction to Common Lisp.&#41;</p> <p><img src="/assets/images/bitcover.jpg" alt="Bit 1985 Cover" /></p> <p>An interesting fact about the classical untyped λ-calculus is that it provides a <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">fixed-point combinator</a> called an <strong>Y-Combinator</strong> that can be used to implement <a href="https://en.wikipedia.org/wiki/Curry&#37;27s_paradox">Curry&#39;s Paradox</a>. It was first implemented by the logician <strong>Haskell Curry</strong> &#40;which Haskell took its name from&#41;.</p> <p>Here&#39;s the Y-Combinator in pure lambda calculus notation. You can read more about <a href="https://sookocheff.com/post/fp/recursive-lambda-functions/">Recursion in λ-calculus</a>.</p> <pre><code class="julia hljs">λf.(λx.(f (x x)) λx.(f (x x)))</code></pre>
<p>Here&#39;s the Y-Combinator in the Scheme language</p>
<pre><code class="lisp hljs">(lambda (f) ((lambda (g) (g g)) 
    (lambda (g) (f (lambda a (apply (g g) a)))))))</code></pre>
<p>From Wikipedia: &quot;Applied to a function with one variable the Y combinator usually does not terminate. More interesting results are obtained by applying the Y combinator to functions of two or more variables. The second variable may be used as a counter, or index. The resulting function behaves like a while or a for loop in an imperative language.</p>
<p>Used in this way the Y combinator implements simple recursion. In the lambda calculus it is not possible to refer to the definition of a function in a function body. Recursion may only be achieved by passing in a function as a parameter. The Y combinator demonstrates this style of programming.&quot;</p>
<p>&#40;Fun fact: <a href="https://news.ycombinator.com/">Hacker News</a> is run by Paul Graham&#39;s investment fund and startup incubator, Y Combinator, that takes the name from Curry&#39;s paradoxical Y-Combinator&#41;</p>
<p>The final part of the interpreter, the <strong>REPL</strong> &#40;Read Eval Print Loop&#41; is the glue between the user and the interpreter. It is a simple program that reads line by line from a file or a terminal interface and evaluates each statement, prints a result and loops back to reading.</p>
<p>Writing and making the evaluator was &#40;and still is&#41; the hardest part of making yasih Scheme. While testing a simple program, I&#39;ve encountered a cryptical error:</p>
<pre><code class="julia hljs">unbound variable: <span class=hljs-keyword >if</span></code></pre>
<p>After hours of debugging I&#39;ve discovered that the error was originating from the fact that I was mishandling evaluation of the <code>if</code> form, and I was lacking an <code>eval</code> pattern matching case to evaluate an <code>if</code> expression without the <code>else</code> branch.</p>
<p><strong>yasih</strong> is not ready for production at all. On the roadmap there&#39;s finishing implementing the R5RS standard, which includes adding <code>defmacro</code>, hygienic macros and some fixes related to character and REPL line parsing. Here are some of the first examples I tested as soon as yasih reached a working status.</p>
<p>Fibonacci Number</p>
<pre><code class="lisp hljs">(<span class=hljs-name >define</span> (<span class=hljs-name >fib-rec</span> n)
  (<span class=hljs-name >if</span> (<span class=hljs-name >&lt;</span> n <span class=hljs-number >2</span>)
      n
      (<span class=hljs-name >+</span> (<span class=hljs-name >fib-rec</span> (<span class=hljs-name >-</span> n <span class=hljs-number >1</span>))
         (<span class=hljs-name >fib-rec</span> (<span class=hljs-name >-</span> n <span class=hljs-number >2</span>)))))</code></pre>
<p>Hanoi Tower Algorithm</p>
<pre><code class="lisp hljs">(<span class=hljs-name >define</span> (<span class=hljs-name >hanoi</span> n a b c)
  (<span class=hljs-name >if</span> (<span class=hljs-name >&gt;</span> n <span class=hljs-number >0</span>)
    (<span class=hljs-name >begin</span>
      (<span class=hljs-name >hanoi</span> (<span class=hljs-name >-</span> n <span class=hljs-number >1</span>) a c b)
      (<span class=hljs-name >display</span> <span class=hljs-string >&quot;Move disk from pole &quot;</span>)
      (<span class=hljs-name >display</span> a)
      (<span class=hljs-name >display</span> <span class=hljs-string >&quot; to pole &quot;</span>)
      (<span class=hljs-name >display</span> b)
      (<span class=hljs-name >newline</span>)
      (<span class=hljs-name >hanoi</span> (<span class=hljs-name >-</span> n <span class=hljs-number >1</span>) c b a))))

(<span class=hljs-name >hanoi</span> <span class=hljs-number >4</span> <span class=hljs-number >1</span> <span class=hljs-number >2</span> <span class=hljs-number >3</span>)</code></pre>
</div>  </main>
  
    </div>  
    
    
        


    
    <footer>
      &copy; Alessandro Cheli.
      Made with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>
      and <a href="https://julialang.org">The Julia Programming Language</a>.
    </footer>