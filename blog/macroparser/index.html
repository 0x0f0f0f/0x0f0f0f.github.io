<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/style.css"> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous  /> <link rel=stylesheet  href="/css/franklin.css"> <link rel=icon  href="/assets/favicon.ico"> <title>Adding a macro parser to my Scheme implementation</title> <header> <a class=title  href="/"><h2>0x0f0f0f - Alessandro Cheli</h2></a> <nav> <a href="/">Home</a> / <a href="/blog">Blog</a> / <a href="/tag/">Tags</a> <div class=social-media > <a style="color: #000000;" href="https://github.com/0x0f0f0f"><i class="fab fa-github"></i></a> <a style="color: #000000;" href=""><i class="fab fa-twitter"></i></a> </div> </nav> </header> <main> <div class=container ><h1>Adding a macro parser to my Scheme implementation</h1> <p>Published 31 October 2019</p> <p><b>Tags: </b><a href="/tag/functional-programming">#functional-programming</a>, <a href="/tag/haskell">#haskell</a>, <a href="/tag/lisp">#lisp</a>, <a href="/tag/yasih">#yasih</a></p><hr/> <p>Happy Halloween everybody, here&#39;s a little report on how I&#39;ve added a macro parser to <a href="https://github.com/0x0f0f0f/yasih">yasih</a> &#40;Yet Another Scheme in Haskell&#41;, my own R5RS Scheme implementation written in Haskell.</p> <p>At first I&#39;ve had to define parsers for <code>quote</code>, <code>quasiquote</code>, and <code>unquote</code> and add them to the expression parser. You can learn more about how scheme quoting works <a href="https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Quoting.html">in the MIT-scheme documentation</a>.</p> <pre><code class=language-haskell >-- |Parse a Quoted Expression &#39;a
parseQuoted :: Parser LispVal
parseQuoted &#61; do
    char &#39;\&#39;&#39;
    x &lt;- parseExpr
    return &#36; List &#91;Atom &quot;quote&quot;, x&#93;

-- |Parse a QuasiQuoted Expression
-- See https://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#&#37;_sec_4.2.6
parseQuasiQuoted :: Parser LispVal
parseQuasiQuoted &#61; do
    char &#39;&#96;&#39;
    x &lt;- parseExpr
    return &#36; List &#91;Atom &quot;quasiquote&quot;, x&#93;

parseUnQuote :: Parser LispVal
parseUnQuote &#61; do
    char &#39;,&#39;
    x &lt;- parseExpr
    return &#36; List &#91;Atom &quot;unquote&quot;, x&#93;</code></pre> <p>Expression parser:</p> <pre><code class=language-haskell >-- |Parse an Expression
parseExpr :: Parser LispVal
parseExpr &#61; try parseComplex
        &lt;|&gt; try parseRatio
        &lt;|&gt; try parseFloat
        &lt;|&gt; try parseNumber
        &lt;|&gt; try parseAtom
        &lt;|&gt; parseString
        &lt;|&gt; try parseBool
        &lt;|&gt; try parseCharacter
        &lt;|&gt; try parseQuoted
        &lt;|&gt; try parseQuasiQuoted
        &lt;|&gt; try parseUnQuote
        &lt;|&gt; try parseVector
        &lt;|&gt; try parseParens</code></pre> <p>The symbols <code>&#39;expr</code>, <code>&#96;expr</code>, and <code>,expr</code> are shorthands and are correspondingly transformed by the parser into the AST equivalent of the expressions: <code>&#40;quote expr&#41;</code>, <code>&#40;quasiquote expr&#41;</code> and <code>&#40;unquote expr&#41;</code>. In fact, the shorthand and list syntaxes are interchangeable. <code>unquote</code> makes sense only inside a <code>quasiquote</code>d block</p> <p>After defining the parsing rules for quoting and unquoting, it is time to define the corresponding evaluation rules as <code>eval</code> pattern matching cases:</p> <pre><code class=language-haskell >-- Evalaute a quoted expression, just return the value.
eval env &#40;List &#91;Atom &quot;quote&quot;, val&#93;&#41; &#61; return val
-- ...

-- Evaluate quasiquotation. AKA macro expander.
-- Recursively evaluate unquote forms, or just return the items if not unquoted
eval env &#40;List &#91;Atom &quot;quasiquote&quot;, form&#93;&#41; &#61;
    evalUnquotes form
    where evalUnquotes form &#61;
            case form of
                List &#91;Atom &quot;unquote&quot;, form&#93; -&gt; eval env form
                List items -&gt; do
                    results &lt;- traverse evalUnquotes items
                    return &#36; List results
                _ -&gt; return form</code></pre> <p>Here&#39;s an example, showing what happens when entering quoted expressions in <strong>yasih</strong>&#39;s REPL.</p> <pre><code class=language-scheme >λ&gt; ; here, the evaluator tries to apply
λ&gt; &#40;1 2 3&#41; ; 2 and 3 as arguments to a function &quot;1&quot;
Not a function: : &quot;1&quot;
λ&gt; ; the result is clearly not a function
λ&gt; ; the list here is now quoted and will be treated as a literal value
λ&gt; &#39;&#40;1 2 3&#41;
&#40;1 2 3&#41;
λ&gt; &#96;&#40;1 2 3&#41; ; same here but using quasiquote
&#40;1 2 3&#41;
λ&gt; &#96;&#40;1 2 ,&#40;&#43; 4 5&#41;&#41; ; the unquoted expression is evaluated&#33; &#40;un-quoted&#41;&#33;
&#40;1 2 9&#41;</code></pre> <p>After we have working quotation and quasiquotation it is time to add actual macros to the interpreter. I had to change the expression data type by adding an <code>isMacro</code> field.</p> <pre><code class=language-haskell >-- |Lisp Value data type
data LispVal &#61;
    -- Other data types here...
    | Func &#123;
        isMacro :: Bool,
        params :: &#91;String&#93;, -- Parameters name
        vararg :: Maybe String, -- name of a variable-length argument list
        body :: &#91;LispVal&#93;, -- list of expressions
        closure :: Env -- the environment where the function was created
        &#125;
    | IOFunc &#40;&#91;LispVal&#93; -&gt; IOThrowsError LispVal&#41; -- A dirty function that performs IO
    | Port Handle -- Represents input and output devices</code></pre> <p>The important bit was changing <code>eval</code>&#39;s function application clause by checking if a called function is a macro, and if so changing from eager evaluation order of the arguments to a normal-order evaluation. Read more about evaluation models <a href="https://cs.stackexchange.com/questions/54000/is-applicative-order-and-normal-order-evaluation-models-definition-contradictor">here</a> &#40;huge thanks to Rei for the link&#41;.</p> <pre><code class=language-haskell >-- Function application clause
-- Run eval recursively over args then apply func over the resulting list
eval env &#40;List &#40;function : args&#41;&#41; &#61; do
    func &lt;- eval env function
    case func of
        Func &#123;isMacro &#61; True&#125; -&gt; apply func args &gt;&gt;&#61; eval env
        _ -&gt; mapM &#40;eval env&#41; args &gt;&gt;&#61; apply func</code></pre> <p>You can see that if the applied function is a macro, then <code>eval env</code> is not called over the arguments. Minor changes were needed also in <code>apply</code>, just adding an <code>isMacro</code> deconstructor to the case where <code>Func</code> is passed as an argument. It is not needed by now inside <code>apply</code>&#39;s body.</p> <pre><code class=language-haskell >apply &#40;Func isMacro params varargs body closure&#41; args &#61;
    -- more code...</code></pre> <p>Now, it&#39;s time to add some helper functions in <code>Environment.hs</code> to make a macro</p> <pre><code class=language-haskell >-- |Helper functions to create function objects in IOThrowsError monad
makeFunc :: Bool -&gt; Maybe String -&gt; Env -&gt; &#91;LispVal&#93; -&gt; &#91;LispVal&#93; -&gt; IOThrowsError LispVal
makeFunc isMacro varargs env params body &#61; return &#36; Func isMacro &#40;map showVal params&#41; varargs body env
makeNormalFunc &#61; makeFunc False Nothing
makeVarargs &#61; makeFunc False . Just . showVal
makeMacro &#61; makeFunc True Nothing</code></pre> <p>Finally, a <code>define-syntax</code> form can be defined to make macros. I have not yet implemented <code>syntax-rules</code> but i surely will in the next <strong>yasih</strong> updates.</p> <pre><code class=language-haskell >-- Define a macro
eval env &#40;List &#40;Atom &quot;define-syntax&quot; : List &#40;Atom var : params&#41; : body&#41;&#41; &#61;
    makeMacro env params body &gt;&gt;&#61; defineVar env var</code></pre> <p>Here&#39;s an example on how you can make a macro and use it as a practical construct for a programming language. Here, the <code>let</code> statement is defined as a macro that will expand to an anonymous function &#40;lambda&#41; application, in this way a closure will be made and lexical scoping will be respected, correctly reaching the <code>let</code> statement&#39;s goals. The implementation is a little sketchy and will surely get better as <code>syntax-rules</code> gets implemented.</p> <pre><code class=language-scheme >&#40;define-syntax &#40;bind-vars bindings&#41;
    &#96;&#40;map car bindings&#41;&#41;

&#40;define-syntax &#40;bind-vals bindings&#41;
    &#96;&#40;map cadr bindings&#41;&#41;

&#40;define-syntax &#40;let bindings body&#41;
    &#96;&#40;apply &#40;lambda ,&#40;bind-vars bindings&#41; ,body&#41; &#39;,&#40;bind-vals bindings&#41;&#41;&#41;</code></pre> <pre><code class=language-scheme >&#40;let &#40;&#40;x 1&#41; &#40;y 4&#41;&#41; &#40;- &#40;* y y&#41; &#40;&#43; 1 x&#41;&#41;&#41;
; will expand to
&#40;&#40;lambda &#40;x y&#41; &#40;- &#40;* y y&#41; &#40;&#43; 1 x&#41;&#41;&#41; 1 4&#41;
; before being executed</code></pre> <p>This practice is called <code>let-over-lambda</code>. Some modern functional programming languages like OCaml, directly create a closure instead of creating an anonymous function for <code>let</code> statements; that practice is fairly more performant, but the execution result is identical.</p> <h2 id=some_updates_on_yasihs_development ><a href="#some_updates_on_yasihs_development" class=header-anchor >Some updates on yasih&#39;s development.</a></h2> <p>A sketchy complete R5RS implementation is almost done. Some primitives are still missing and I will work on them in the next updates, in which I will also focus on adding additional features like string interpolation, stack tracing, and probably optimization features like a garbage collector.</p> </div> </main> </div> <script src="/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script> <footer> &copy; Alessandro Cheli. Made with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://julialang.org">The Julia Programming Language</a>. </footer>